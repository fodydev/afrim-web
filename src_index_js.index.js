"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkafrim_playground"] = self["webpackChunkafrim_playground"] || []).push([["src_index_js"],{

/***/ "../afrim-input/src/config.js":
/*!************************************!*\
  !*** ../afrim-input/src/config.js ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AfrimConfig: () => (/* binding */ AfrimConfig)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"../afrim-input/src/utils.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_utils__WEBPACK_IMPORTED_MODULE_0__]);\n_utils__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n// Load the afrim configuration through an URL.\nclass AfrimConfig {\n  config = Object({\n    data: Object({}),\n    dictionary: Object({}),\n    translators: Object({}),\n  });\n\n  constructor() {}\n\n  async loadFromUrl(configUrl) {\n    const data = await (0,_utils__WEBPACK_IMPORTED_MODULE_0__.httpGet)(configUrl);\n    const content = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.tomlToJson)(data);\n    let auto_capitalize = false;\n\n    if (content.has(\"core\")) {\n      auto_capitalize = content.get(\"core\").get(\"auto_capitalize\") || false;\n    }\n\n    if (content.has(\"translation\")) {\n      for (const translation of content.get(\"translation\")) {\n        const key = translation[0];\n        const value = translation[1];\n\n        // We extract the translation.\n        if (typeof value == \"string\") {\n          this.config.dictionary[key] = [value];\n        } else if (value.has(\"path\")) {\n          await this.loadFromUrl(new URL(value.get(\"path\"), configUrl).href);\n        } else if (value.has(\"alias\")) {\n          let data = null;\n\n          if (value.has(\"values\")) {\n            data = value.get(\"values\");\n          } else {\n            data = [value.get(\"value\")];\n          }\n\n          for (const alias of value.get(\"alias\")) {\n            this.config.dictionary[alias] = data;\n          }\n          this.config.dictionary[key] = data;\n        } else {\n          throw new Error(`load config error: ${value} unexpected`);\n        }\n      }\n    }\n\n    // We extract the data.\n    if (content.has(\"data\")) {\n      for (const data of content.get(\"data\")) {\n        const key = data[0];\n        const value = data[1];\n\n        if (typeof value == \"string\") {\n          this.config.data[key] = value;\n        } else if (value.has(\"path\")) {\n          await this.loadFromUrl(new URL(value.get(\"path\"), configUrl).href);\n        } else if (value.has(\"alias\")) {\n          const data = value.get(\"value\");\n          for (const alias of value.get(\"alias\")) {\n            this.config.data[alias] = data;\n\n            if (auto_capitalize) {\n              this.config.data[data[0].toUpperCase() + data.slice(1)] =\n                data.toUpperCase();\n            }\n          }\n          this.config.data[key] = data;\n\n          if (auto_capitalize) {\n            this.config.data[key[0].toUpperCase() + key.slice(1)] =\n              data.toUpperCase();\n          }\n        } else {\n          throw new Error(`load config error: ${value} unexpected`);\n        }\n      }\n    }\n\n    // We extract the translators.\n    if (content.has(\"translators\")) {\n      for (const translator of content.get(\"translators\")) {\n        const key = translator[0];\n        const value = translator[1];\n        const data = await (0,_utils__WEBPACK_IMPORTED_MODULE_0__.httpGet)(new URL(value, configUrl).href);\n\n        this.config.translators[key] = data;\n      }\n    }\n  }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://afrim-playground/../afrim-input/src/config.js?");

/***/ }),

/***/ "../afrim-input/src/index.js":
/*!***********************************!*\
  !*** ../afrim-input/src/index.js ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Afrim)\n/* harmony export */ });\n/* harmony import */ var afrim_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! afrim-js */ \"../../node_modules/afrim-js/afrim_js.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ \"../afrim-input/src/config.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([afrim_js__WEBPACK_IMPORTED_MODULE_0__, _config__WEBPACK_IMPORTED_MODULE_1__]);\n([afrim_js__WEBPACK_IMPORTED_MODULE_0__, _config__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n// TODO: implement cancelAnimationFrame\nclass Afrim {\n  // For bindings.\n  #textFieldElement;\n  #downloadStatusElement;\n  #tooltipElement;\n  #tooltipInputElement;\n  #tooltipPredicatesElement;\n\n  // Afrim lib.\n  #preprocessor;\n  #translator;\n\n  // Data\n  #data = Object({\n    predicates: Array(),\n    predicateId: 0,\n    pageSize: 5,\n    isIdle: false,\n    cursorPos: 0,\n    options: Object(),\n  });\n\n  #animation;\n\n  constructor(options) {\n    let defaultOptions = {\n      textFieldElementID: \"textfield\",\n      downloadStatusElementID: \"download-status\",\n      tooltipElementID: \"tooltip\",\n      tooltipInputElementID: \"tooltip-input\",\n      tooltipPredicatesElementID: \"tooltip-predicates\",\n      tooltipPredicateClass: \"dropdown-item\",\n      tooltipAdjustLeft: 50,\n      tooltipAdjustTop: 125,\n      configUrl:\n        \"https://raw.githubusercontent.com/pythonbrad/afrim-data/4b177197bb37c9742cd90627b1ad543c32ec791b/gez/gez.toml\",\n    };\n\n    // merge the options passed in with our default options\n    // properties that exist in the incoming options object will overwrite that in the defaultOptions\n    options = { ...defaultOptions, ...options };\n\n    // Binding\n    this.#textFieldElement = document.getElementById(\n      options.textFieldElementID,\n    );\n    this.#downloadStatusElement = document.getElementById(\n      options.downloadStatusElementID,\n    );\n    this.#tooltipElement = document.getElementById(options.tooltipElementID);\n    this.#tooltipInputElement = document.getElementById(\n      options.tooltipInputElementID,\n    );\n    this.#tooltipPredicatesElement = document.getElementById(\n      options.tooltipPredicatesElementID,\n    );\n\n    // Save options\n    this.#data.options = options;\n\n    // Prevent another afrim instance.\n    if (this.#textFieldElement.dataset.lock) {\n      throw new Error(\"An afrim instance is already linked to this element.\");\n    }\n\n    this.#textFieldElement.dataset.lock = true;\n\n    // We wait that the afrim ime engine is ready.\n    // We mark the text field busy.\n    this.#textFieldElement.disabled = true;\n    this.#downloadStatusElement.hidden = false;\n\n    this.#loadConfigFromUrl(options.configUrl).then(\n      (config) => {\n        this.#initAfrim(config);\n        this.#listenKeyboard();\n        this.#listenMouse();\n        this.#listenTextFieldState();\n\n        // We start the processor.\n        this.#processCommand();\n\n        // We mark the text field available.\n        this.#textFieldElement.disabled = false;\n        this.#downloadStatusElement.hidden = true;\n      },\n      (err) => {\n        alert(`Error downloading configuration file: ${err}`);\n      },\n    );\n  }\n\n  // Clear the predicates.\n  #clearPredicate() {\n    this.#tooltipPredicatesElement.innerHTML = \"\";\n\n    this.#data.predicateId = 0;\n    this.#data.predicates = Array();\n  }\n\n  // Load predicates in the memory\n  #loadPredicates(predicates) {\n    this.#clearPredicate();\n    var predicateId = 0;\n\n    for (const predicate of predicates) {\n      for (const text of predicate.texts) {\n        this.#data.predicates.push([\n          ++predicateId,\n          predicate.code,\n          predicate.remaining_code,\n          text,\n          predicate.can_commit,\n        ]);\n      }\n    }\n  }\n\n  // Update the predicates.\n  #updatePredicate() {\n    this.#tooltipPredicatesElement.innerHTML = \"\";\n\n    let counter = 0;\n    // We get the current the page\n    const predicates = this.#data.predicates\n      .slice(this.#data.predicateId, this.#data.predicates.length)\n      .concat(this.#data.predicates.slice(0, this.#data.predicateId));\n\n    for (const predicate of predicates) {\n      // Mark the selected predicate.\n      const c = counter == 0 ? \"✏️\" : \"\";\n\n      if (counter++ > this.#data.pageSize) break;\n\n      // Config the tooltip predicate element.\n      const el = document.createElement(\"a\");\n      el.classList.add(this.#data.options.tooltipPredicateClass);\n      el.innerText = `${c} ${predicate[0]}. ${predicate[3]} ~${predicate[2]}`;\n      for (let e of [\"pointerdown\", \"click\"]) {\n        el.addEventListener(\n          e,\n          () => {\n            this.#preprocessor.commit(predicate[3]);\n            this.#preprocessor.process(\"\", \"keydown\");\n            this.#clearPredicate();\n          },\n          false,\n        );\n      }\n      this.#tooltipPredicatesElement.append(el);\n    }\n  }\n\n  // Restore cursor position.\n  #restoreCursorPosition() {\n    this.#textFieldElement.focus();\n    this.#textFieldElement.setSelectionRange(\n      this.#data.cursorPos,\n      this.#data.cursorPos,\n    );\n  }\n\n  // We execute preprocessor commands in idle.\n  #processCommand() {\n    const cmd = this.#preprocessor.popQueue();\n    const textValue = this.#textFieldElement.value;\n\n    this.#data.cursorPos = this.#data.cursorPos < 0 ? 0 : this.#data.cursorPos;\n\n    if (cmd) {\n      if (cmd == \"Delete\") {\n        this.#textFieldElement.value =\n          textValue.substring(0, this.#data.cursorPos - 1) +\n          textValue.substring(this.#data.cursorPos, textValue.length);\n        this.#data.cursorPos--;\n        this.#restoreCursorPosition();\n      } else if (cmd == \"Pause\") {\n        this.#data.isIdle = true;\n      } else if (cmd == \"Resume\") {\n        this.#data.isIdle = false;\n      } else if (cmd == \"NOP\") {\n      } else if (cmd.CommitText) {\n        this.#textFieldElement.value =\n          textValue.substring(0, this.#data.cursorPos) +\n          cmd.CommitText +\n          textValue.substring(this.#data.cursorPos, textValue.length);\n        this.#data.cursorPos += cmd.CommitText.length;\n        this.#restoreCursorPosition();\n      } else {\n        console.error(`afrim command \"${cmd}\" unsupported.`);\n      }\n    }\n\n    this.#animation = requestAnimationFrame(() => this.#processCommand());\n  }\n\n  async #loadConfigFromUrl(configUrl) {\n    // We download the datalang.\n    let afrimConfig = new _config__WEBPACK_IMPORTED_MODULE_1__.AfrimConfig();\n    await afrimConfig.loadFromUrl(configUrl);\n\n    return afrimConfig.config;\n  }\n\n  // We config the afrim ime.\n  #initAfrim(config) {\n    this.#preprocessor = new afrim_js__WEBPACK_IMPORTED_MODULE_0__.Preprocessor(config.data, 64);\n    this.#translator = new afrim_js__WEBPACK_IMPORTED_MODULE_0__.Translator(config.dictionary, false);\n\n    for (let e of Object.entries(config.translators)) {\n      this.#translator.register(e[0], e[1]);\n    }\n  }\n\n  #listenKeyboard() {\n    // We listen keyboard events.\n    this.#textFieldElement.addEventListener(\n      \"keyup\",\n      (event) => {\n        this.#data.cursorPos = this.#textFieldElement.selectionEnd;\n\n        // We manage special keys.\n        if (event.ctrlKey) {\n          // Previous predicate.\n          if (event.code == \"ShiftLeft\") {\n            this.#data.predicateId =\n              this.#data.predicateId < 1\n                ? this.#data.predicates.length - 1\n                : this.#data.predicateId - 1;\n            this.#updatePredicate();\n          }\n          // Next predicate.\n          else if (event.code == \"ShiftRight\") {\n            this.#data.predicateId =\n              this.#data.predicateId >= this.#data.predicates.length - 1\n                ? 0\n                : this.#data.predicateId + 1;\n            this.#updatePredicate();\n          }\n          // Commit the predicate.\n          else if (event.code == \"Space\") {\n            var predicate = this.#data.predicates[this.#data.predicateId];\n\n            if (predicate) this.#preprocessor.commit(predicate[3]);\n            this.#clearPredicate();\n          } else if (\n            event.code == \"ControlLeft\" ||\n            event.code == \"ControlRight\"\n          ) {\n            this.#data.isIdle = !this.#data.idle;\n          }\n\n          return;\n        }\n\n        if (event.key == \"GroupPrevious\" || event.key == \"GroupNext\") return;\n        if (this.#data.isIdle) return;\n\n        const changed = this.#preprocessor.process(event.key, \"keydown\");\n        const input = this.#preprocessor.getInput();\n\n        // We update the predicates\n        if (!changed) return;\n\n        this.#tooltipInputElement.innerText = \"📝 \" + input;\n\n        const predicates = this.#translator.translate(input);\n        this.#loadPredicates(predicates);\n        this.#updatePredicate();\n      },\n      false,\n    );\n  }\n\n  #listenMouse() {\n    // Make the tooltip follow the mouse.\n    this.#textFieldElement.addEventListener(\n      \"keyup\",\n      (event) => {\n        const getCaretCoordinates = __webpack_require__(/*! textarea-caret */ \"../../node_modules/textarea-caret/index.js\");\n        const caret = getCaretCoordinates(\n          this.#textFieldElement,\n          this.#textFieldElement.selectionEnd,\n        );\n\n        this.#tooltipElement.style.top =\n          this.#data.options.tooltipAdjustTop +\n          this.#textFieldElement.offsetTop -\n          this.#textFieldElement.scrollTop +\n          caret.top +\n          \"px\";\n        this.#tooltipElement.style.left =\n          this.#data.options.tooltipAdjustLeft +\n          this.#textFieldElement.offsetLeft -\n          this.#textFieldElement.scrollLeft +\n          caret.left +\n          \"px\";\n      },\n      false,\n    );\n  }\n\n  #listenTextFieldState() {\n    // Make the tooltip active inside of the textfield.\n    for (let e of [\"click\", \"touchstart\"]) {\n      this.#textFieldElement.addEventListener(\n        e,\n        () => {\n          this.#tooltipElement.classList.add(\"is-active\");\n          this.#preprocessor.process(\"\", \"keydown\");\n          this.#clearPredicate();\n        },\n        false,\n      );\n    }\n\n    // Hide the tooltip if not typing\n    this.#textFieldElement.addEventListener(\"blur\", (e) => {\n      this.#tooltipElement.classList.remove(\"is-active\");\n    });\n  }\n\n  kill() {\n    cancelAnimationFrame(this.#animation);\n\n    this.#textFieldElement.replaceWith(this.#textFieldElement.cloneNode(true));\n    this.#translator.free();\n    this.#preprocessor.free();\n\n    delete this.#textFieldElement.dataset.lock;\n  }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://afrim-playground/../afrim-input/src/index.js?");

/***/ }),

/***/ "../afrim-input/src/utils.js":
/*!***********************************!*\
  !*** ../afrim-input/src/utils.js ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   httpGet: () => (/* binding */ httpGet),\n/* harmony export */   tomlToJson: () => (/* binding */ tomlToJson)\n/* harmony export */ });\n/* harmony import */ var afrim_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! afrim-js */ \"../../node_modules/afrim-js/afrim_js.js\");\n/* harmony import */ var ky__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ky */ \"../../node_modules/ky/distribution/index.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([afrim_js__WEBPACK_IMPORTED_MODULE_0__]);\nafrim_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\n// Convert TOML to JSON.\nfunction tomlToJson(data) {\n  return (0,afrim_js__WEBPACK_IMPORTED_MODULE_0__.convertTomlToJson)(data);\n}\n\n// Make a http get request.\n// HTTP because we want a fast request.\nasync function httpGet(url) {\n  const response = await (0,ky__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(url);\n\n  if (!response.ok) throw new Error(`Fetch error: ${response.statusText}`);\n\n  return await response.text();\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://afrim-playground/../afrim-input/src/utils.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Afrim: () => (/* reexport safe */ afrim_input__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var afrim_input__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! afrim-input */ \"../afrim-input/src/index.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([afrim_input__WEBPACK_IMPORTED_MODULE_0__]);\nafrim_input__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://afrim-playground/./src/index.js?");

/***/ })

}]);